#!/usr/bin/env python

import SocketServer
import roslib
import rospy
import thread
import tf

#from geometry_msgs.msg import Pose
#from std_msgs.msg import Int8

class HandDataListener(SocketServer.BaseRequestHandler):
    """
    The RequestHandler class for our server. Currently only echos received data. This need to be moved into a ROS node.
    """

    def setup(self):
        """
        Initialization happens here (default does nothing).
        :return: none
        """
        rospy.loginfo("SocketServer received request from {}...".format(self.client_address[0]))
        self.tf_broadcaster = tf.TransformBroadcaster()
        self.tf_listener = tf.TransformListener()
        self.KinectOriX = 0.0
        self.KinectOriY = 0.0
        self.KinectOriZ = 0.0
        self.KinectOriW = 1.0

    def handle(self):
        """
        Handle the data stream connection.
        :return: none
        """
        self.data = self.request[0].strip()
        if self.data != "":
            rospy.loginfo("{} wrote: ".format(self.client_address[0]) + self.data)

            # split data
            splitData = self.data.split("|")
            handDisp = splitData[0].split(",")
            handRef = splitData[1]

            # update ref frame
            if(handRef != ""):
                try:
                    t = getLatestCommonTime('mico_link_hand', 'root')
                    (trans,rot) = self.tf_listener.lookupTransformFull('mico_link_hand', t, 'root', t, 'mico_api_origin')
                except (tf.LookupException, tf.ConnectivityException, tf.ExtrapolationException):
                    return

                # move Kinect sensor frame to ee
                self.tf_broadcaster.sendTransform(trans,(self.KinectOriX,self.KinectOriY,self.KinectOriZ,self.KinectOriW),rospy.Time.now(),"kinect_frame","mico_api_origin")

                # update hand ref frame orientation
                ref_data = handRef.split(",")
                self.xOriRef = float(ref_data[0])
                self.yOriRef = float(ref_data[1])
                self.zOriRef = float(ref_data[2])
                self.wOriRef = float(ref_data[3])
                self.tf_broadcaster.sendTransform((0,0,0),(self.xOriRef,self.yOriRef,self.zOriRef,self.wOriRef),rospy.Time.now(),"hand_ref_frame","kinect_frame")

            # update displacement
            xPosDisp = float(handDisp[0])
            yPosDisp = float(handDisp[1])
            zPosDisp = float(handDisp[2])
            xOriDisp = float(handDisp[3])
            yOriDisp = float(handDisp[4])
            zOriDisp = float(handDisp[5])
            wOriDisp = float(handDisp[6])
            handState = int(handDisp[7])

            # calc tranform
            q_disp = [xOriDisp, yOriDisp, zOriDisp, wOriDisp]
            q_ref = [self.xOriRef, self.yOriRef, self.zOriRef, self.wOriRef]
            q_ref_inv = tf.transformations.quaternion_inverse(q_ref)
            q = tf.transformations.quaternion_multiply(q_ref_inv, q_disp)
            self.tf_broadcaster.sendTransform((xPosDisp, yPosDisp, zPosDisp),(q[0],q[1],q[2],q[3]),rospy.Time.now(),"hand_disp_frame","hand_ref_frame")

if __name__ == '__main__':
    HOST, PORT = "localhost", 5050

    # Create the server, binding to localhost on port 5050
    rospy.loginfo("Starting SocketServer...")
    server = SocketServer.UDPServer((HOST, PORT), HandDataListener)

    # function to stop listening (requires new thread)
    def ROSShutdown():
        rospy.loginfo("Attempting shutdown of SocketServer...")
        
        def StopSocketListener(_s):
            _s.shutdown()
            
        thread.start_new_thread(StopSocketListener, (server,))
        rospy.loginfo("...Done!")

    # start ROS node
    rospy.init_node('HandDataListener', anonymous=True)
    rospy.on_shutdown(ROSShutdown)

    # Activate the server; this will keep running until you
    # interrupt the program with Ctrl-C
    rospy.loginfo("SocketServer listening for connections...")
    server.serve_forever()
